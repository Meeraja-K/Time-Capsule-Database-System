{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/data/db.ts"],"sourcesContent":["import mysql from 'mysql2/promise';\r\n\r\n// Create a connection pool for MySQL\r\nconst pool = mysql.createPool({\r\n  host: process.env.DB_HOST || 'localhost', // Replace with your MySQL host\r\n  user: process.env.DB_USER || 'root', // Replace with your MySQL username\r\n  password: process.env.DB_PASSWORD || '#InsideOut6', // Replace with your MySQL password\r\n  database: process.env.DB_NAME || 'timecapsuledbs', // Replace with your database name\r\n  waitForConnections: true,\r\n  connectionLimit: 10,\r\n  queueLimit: 0,\r\n});\r\n\r\nexport default pool;\r\n"],"names":[],"mappings":";;;AAAA;;AAEA,qCAAqC;AACrC,MAAM,OAAO,mIAAA,CAAA,UAAK,CAAC,UAAU,CAAC;IAC5B,MAAM,QAAQ,GAAG,CAAC,OAAO,IAAI;IAC7B,MAAM,QAAQ,GAAG,CAAC,OAAO,IAAI;IAC7B,UAAU,QAAQ,GAAG,CAAC,WAAW,IAAI;IACrC,UAAU,QAAQ,GAAG,CAAC,OAAO,IAAI;IACjC,oBAAoB;IACpB,iBAAiB;IACjB,YAAY;AACd;uCAEe"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/app/api/updateProfile/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport db from \"../../../data/db\";\r\nimport { RowDataPacket } from \"mysql2\";\r\n\r\nconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json();\r\n    const { userId, field, currentValue, newValue } = body;\r\n\r\n    // Validate input\r\n    if (!userId || !field || !currentValue || !newValue) {\r\n      return NextResponse.json(\r\n        { error: \"All fields (userId, field, currentValue, newValue) are required\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Validate the field being updated\r\n    const validFields = [\"username\", \"email\", \"password_hash\"];\r\n    if (!validFields.includes(field)) {\r\n      return NextResponse.json(\r\n        { error: `Field '${field}' is not valid` },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const [userRows] = await db.query<RowDataPacket[]>(\r\n        \"SELECT user_id, password_hash FROM users WHERE username = ?\",\r\n        [userId] // Use the 'userId' which is actually the 'username' in this case\r\n      );\r\n  \r\n      if (userRows.length === 0) {\r\n        return NextResponse.json(\r\n          { error: \"User not found\" },\r\n          { status: 404 }\r\n        );\r\n      }\r\n  \r\n      const user_id = userRows[0].user_id;\r\n      const storedPassword = userRows[0].password_hash;  \r\n\r\n    if (field === \"username\") {\r\n        const [existingUser] = await db.query<RowDataPacket[]>(\r\n          \"SELECT * FROM users WHERE username = ?\",\r\n          [newValue]\r\n        );\r\n  \r\n        if (existingUser.length > 0) {\r\n          return NextResponse.json(\r\n            { error: \"Username is already taken\" },\r\n            { status: 400 }\r\n          );\r\n        }\r\n      }\r\n\r\n       // Check for email format and uniqueness\r\n    if (field === \"email\") {\r\n        if (!emailRegex.test(newValue)) {\r\n          return NextResponse.json(\r\n            { error: \"Invalid email format\" },\r\n            { status: 400 }\r\n          );\r\n        }\r\n  \r\n        const [existingEmail] = await db.query<RowDataPacket[]>(\r\n          \"SELECT * FROM users WHERE email = ?\",\r\n          [newValue]\r\n        );\r\n  \r\n        if (existingEmail.length > 0) {\r\n          return NextResponse.json(\r\n            { error: \"Email is already taken\" },\r\n            { status: 400 }\r\n          );\r\n        }\r\n      }\r\n\r\n    // Ensure the current value matches the database\r\n    if (field === \"password_hash\") {\r\n        // Directly compare plain text password\r\n        if (currentValue !== storedPassword) {\r\n          return NextResponse.json(\r\n            { error: \"Current password is incorrect\" },\r\n            { status: 401 }\r\n          );\r\n        }\r\n      } else {\r\n        // For other fields, directly compare the current value\r\n        const [rows] = await db.query<RowDataPacket[]>(\r\n          `SELECT ${field} FROM users WHERE user_id = ?`,\r\n          [user_id]\r\n        );\r\n\r\n    if (rows.length === 0 || rows[0][field] !== currentValue) {\r\n      return NextResponse.json(\r\n        { error: \"Current value does not match the database record\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n}\r\n\r\n    // Update the field in the database\r\n    await db.query(\r\n      `UPDATE users SET ${field} = ? WHERE user_id = ?`,\r\n      [newValue, user_id]\r\n    );\r\n\r\n    return NextResponse.json({ success: true, message: \"Profile updated successfully\" });\r\n  } catch (error) {\r\n    console.error(\"Error updating profile:\", error);\r\n    return NextResponse.json({ error: \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}